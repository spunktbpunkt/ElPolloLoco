<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: world.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: world.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>class World {
    coolDown = 250;
    gameEnd = false;
    isPaused = false;
    characterDead = false;
    endbossDead = false;
    animationFrameId = null;
    previousKeyboardD = null;
    worldInterval;
    constructor(canvas, keyboard, level) {
        this.ctx = canvas.getContext('2d');
        this.canvas = canvas;
        this.keyboard = keyboard;
        this.level = level;
        this.character = new Character();
        this.throwableObjects = [];
        this.statusBarEnergy = new Statusbar('energy');
        this.statusBarBottles = new Statusbar('bottle');
        this.statusBarCoins = new Statusbar('coin');
        this.statusBarEndboss = new Statusbar('endboss');
        this.lastThrowTime = 0;
        this.now = 0;
        this.coin_sound = new Audio('audio/coin.mp3');
        this.draw();
        this.setWorld();
        this.run();
    }

    /**
     * This method starts the World
     * 
     */
    run() {
        this.worldInterval = setInterval(() => {
            this.checkCollisions();
            this.checkThrowObject();
        }, 100);
    }

    /**
     * This method start errorSoundBottleThrow, then starts
     * newBottle() if 3 conditions are true
     * 
     * 
     */
    checkThrowObject() {
        this.errorSoundBottleThrow(); // Erst Fehlerprüfung

        if (this.keyboard.D &amp;&amp; this.checkCoolDown() &amp;&amp; this.character.bottlesAmount > 0) {
            this.newBottle()
        }

        this.previousKeyboardD = this.keyboard.D;
    }

    /**
     * Creates a new ThrowableObject (bottle) and throws it
     * 
     */
    newBottle() {
        this.lastThrowTime = this.now;
        let bottle = new ThrowableObject(this.character.x + 100, this.character.y + 100)
        bottle.world = this;
        this.throwableObjects.push(bottle)
        bottle.throw();
        this.character.bottlesAmount--;
        this.statusBarBottles.setPercentage(this.character.bottlesAmount, 5);
        this.addingBottlesToMap()
    }

    /**
     * New Bottles will be added to the map if 2 conditions are true
     * 
     */
    addingBottlesToMap() {
        if (this.character.bottlesAmount === 0 &amp;&amp; this.level.bottles.length == 0) {
            this.level.bottles.push(...createElements('bottles', 5, 200, 100));
        }
    }

    /**
     * Plays an error Sound if the the bottles amount is less then 1 and keyboard D is pushed
     * 
     */
    errorSoundBottleThrow() {
        console.log(this.character.bottlesAmount)
        if (this.keyboard.D &amp;&amp; this.character.bottlesAmount &lt; 1 &amp;&amp; !this.previousKeyboardD) {
            let errorSound = new Audio('audio/error.wav');
            this.character.playSound(errorSound, 1)
        }
    }

    /**
     * Checks different types of Collisions
     * 
     */
    checkCollisions() {
        if (!this.gameEnd) {
            this.characterCollisionEnemy()
            this.characterCollisionEndboss()
            this.characterCollisionCoin()
            this.characterCollisionBottle()
        }
    }

    /**
     * Checks if the character is colliding with a normal enemy by comparing the frames of the images from the character an all enemies
     * 
     */
    characterCollisionEnemy() {
        for (let i = this.level.enemies.length - 1; i >= 0; i--) {
            let enemy = this.level.enemies[i];
            this.character.definingOffsetFrame();
            enemy.definingOffsetFrame();

            if (enemy.isDead === undefined) enemy.isDead = false;

            if (this.character.isColliding(enemy) &amp;&amp; !enemy.isDead) {
                if (this.character.falling &amp;&amp; this.character.y &lt; enemy.y) {
                    this.killEnemy(enemy, i);
                } else {
                    this.character.hit();
                    this.statusBarEnergy.setPercentage(this.character.energy, 100);
                }
            }
        }
    }

    /**
     * Kills a normal enemy and removes it from the enemy-array
     * 
     * @param {object} enemy 
     * @param {integer} index 
     */
    killEnemy(enemy, index) {
        enemy.loadImages(enemy.images_dead);
        enemy.img = enemy.imageCache[enemy.images_dead[0]];
        enemy.isDead = true;

        if (!enemy.isBoss) {
            setTimeout(() => {
                this.level.enemies.splice(index, 1);
            }, 500);
        }
    }

    /**
     * This method checks if the character is colliding with the bottles on the floor and adds them to the statusbar
     * 
     */
    characterCollisionBottle() {
        for (let i = this.level.bottles.length - 1; i >= 0; i--) {
            let bottle = this.level.bottles[i];
            this.character.definingOffsetFrame();
            bottle.definingOffsetFrame();

            if (this.character.isColliding(bottle)) {
                this.character.bottlesAmount++;
                this.statusBarBottles.setPercentage(this.character.bottlesAmount, 5);
                this.level.bottles.splice(i, 1);
            }
        }
    }

    /**
     * This method checks if the character is colliding with the coins in the air and adds them to the statusbar
     * 
     */
    characterCollisionCoin() {
        for (let i = this.level.coins.length - 1; i >= 0; i--) {
            let coin = this.level.coins[i];
            this.character.definingOffsetFrame();
            coin.definingOffsetFrame();

            if (this.character.isColliding(coin)) {
                this.character.coinsAmount++;
                this.character.playSound(this.coin_sound, 1)
                this.statusBarCoins.setPercentage(this.character.coinsAmount, 5);
                this.level.coins.splice(i, 1);
            }
        }
    }

    /**
     * Checks if the character is colliding with the endboss by comparing the frames of the images from the character an the endboss
     * 
     */
    characterCollisionEndboss() {
        this.level.endboss.forEach(endboss => {
            this.character.definingOffsetFrame();
            endboss.definingOffsetFrame();
            if (this.character.isColliding(endboss) &amp;&amp; !endboss.isDead) {
                this.character.hit();
                this.statusBarEnergy.setPercentage(this.character.energy)
            };
        });
    }

    /**
     * Checks the collision between the thrown bottles and the enemies/endboss
     * 
     */
    checkBottleCollisions() {
        this.throwableObjects.forEach(bottle => {
            this.bottleCollisionEnemy(bottle);
            this.bottleCollisionEndboss(bottle);
        });
    }

    /**
     * Starts another methods for each enemy in the array level.enemies which are needed for checking collisions
     * 
     * @param {object} bottle 
     */
    bottleCollisionEnemy(bottle) {
        this.level.enemies.forEach(enemy => {
            enemy.definingOffsetFrame();
            bottle.definingOffsetFrame();
            if (bottle.isColliding(enemy)) {
                enemy.die();
                bottle.bottleSplash();
            }
        });
    }

    /**
     * Starts another methods for each endboss in the array level.endboss which are needed for checking collisions
     * 
     * @param {object} bottle 
     */
    bottleCollisionEndboss(bottle) {
        if (this.checkCoolDown()) {
            this.lastThrowTime = this.now;
            this.level.endboss.forEach(endboss => {
                endboss.definingOffsetFrame();
                bottle.definingOffsetFrame();
                if (bottle.isColliding(endboss)) {
                    endboss.hit();
                    bottle.bottleSplash();
                }
            });
        }
    }

    /**
     * checks if the difference between lastThrowTime and the current Time is equal or bigger then 250ms
     * 
     */
    checkCoolDown() {
        this.now = Date.now();
        return (this.now - this.lastThrowTime >= this.coolDown);
    }

    /**
     * Sets world reference for all game objects and starts enemy animations.
     * 
     */
    setWorld() {
        this.character.world = this;

        this.level.enemies.forEach(enemy => {
            enemy.world = this;
            enemy.animate();
        });

        this.level.endboss.forEach(endboss => {
            endboss.world = this;
            endboss.animate();
        });

        this.level.clouds.forEach(cloud => {
            cloud.world = this;
        });
    }

    /**
    * Main render loop that draws all game objects to the canvas.
    * 
    */
    draw() {
        if (this.gameEnd) {
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            return;
        }

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground();
        this.drawStatusBars();
        this.drawGameObjects();

        if (!isPaused) {
            this.animationFrameId = requestAnimationFrame(() => this.draw());
        }
    }

    /**
     * Draws background elements with camera translation.
     * 
     */
    drawBackground() {
        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.level.backgroundObjects);
        this.addObjectsToMap(this.level.clouds);
        this.ctx.translate(-this.camera_x, 0);
    }

    /**
     * Draws all status bars and UI elements.
     * 
     */
    drawStatusBars() {
        this.addToMap(this.statusBarEnergy);
        this.addToMap(this.statusBarBottles);
        this.addToMap(this.statusBarCoins);

        if (this.level.endboss[0]?.hadFirstContact) {
            this.addToMap(this.statusBarEndboss);
        }
    }

    /**
     * Draws all interactive game objects with camera translation.
     * 
     */
    drawGameObjects() {
        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.level.coins);
        this.addObjectsToMap(this.level.bottles);
        this.addObjectsToMap(this.level.endboss);
        this.addObjectsToMap(this.level.enemies);
        this.addToMap(this.character);
        this.addObjectsToMap(this.throwableObjects);
        this.ctx.translate(-this.camera_x, 0);
    }

    /**
     * Adds objects from an array to the map
     * 
     * @param {object} array 
     */
    addObjectsToMap(array) {
        array.forEach(obj => {
            this.addToMap(obj)
        });
    }

    /**
     * Adds an single Object to the map, checks the direction of it and flip the image if necessary
     * 
     * @param {object} mo 
     */
    addToMap(mo) {
        if (mo.otherDirection) {
            this.flipImage(mo)
        }
        mo.drawing(this.ctx)
        if (mo.otherDirection) {
            this.flipImageBack(mo)
        }
    }

    /**
     * Flips the Image
     * 
     * @param {object} mo 
     */
    flipImage(mo) {
        this.ctx.save();
        this.ctx.translate(mo.width, 0);
        this.ctx.scale(-1, 1);
        mo.x = mo.x * -1;
    }

    /**
     * Flips the Image back 
     * 
     * @param {object} mo 
     */
    flipImageBack(mo) {
        mo.x = mo.x * -1;
        this.ctx.restore();
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Jul 20 2025 20:50:57 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
