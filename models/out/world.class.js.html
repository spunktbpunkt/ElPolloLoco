<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: world.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: world.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>class World {
    coolDown = 250;
    gameEnd = false;
    isPaused = false;
    characterDead = false;
    endbossDead = false;
    animationFrameId = null;
    previousKeyboardD = null;
    worldInterval;
    constructor(canvas, keyboard, level) {
        this.ctx = canvas.getContext('2d');
        this.canvas = canvas;
        this.keyboard = keyboard;
        this.level = level;
        this.character = new Character();
        this.throwableObjects = [];
        this.statusBarEnergy = new Statusbar('energy');
        this.statusBarBottles = new Statusbar('bottle');
        this.statusBarCoins = new Statusbar('coin');
        this.statusBarEndboss = new Statusbar('endboss');
        this.lastThrowTime = 0;
        this.now = 0;
        this.coin_sound = new Audio('audio/coin.mp3');
        this.camera_x = 0;
        this.endbossProjectiles = [];
        this.brokenProjectiles = [];
        this.draw();
        this.setWorld();
        this.run();
    }

    /**
     * This method starts the World
     * 
     */
    run() {
        this.worldInterval = setInterval(() => {
            checkCollisions();
            this.checkThrowObject();
            this.checkEndbossProjectileCollisions();
        }, 100);
    }

    /**
     * Checks collision between endboss projectiles and character
     * 
     * @returns {void}
     */
    checkEndbossProjectileCollisions() {
        for (let i = this.endbossProjectiles.length - 1; i >= 0; i--) {
            let projectile = this.endbossProjectiles[i];
            this.character.definingOffsetFrame();
            projectile.definingOffsetFrame();

            if (this.character.isColliding(projectile)) {
                this.character.hit();
                this.statusBarEnergy.setPercentage(this.character.energy, 100);
                projectile.projectileBreak();
                break;
            }
        }
    }

    /**
     * This method start errorSoundBottleThrow, then starts
     * newBottle() if 3 conditions are true
     * 
     * 
     */
    checkThrowObject() {
        this.errorSoundBottleThrow();

        if (this.keyboard.D &amp;&amp; this.checkCoolDown() &amp;&amp; this.character.bottlesAmount > 0) {
            this.newBottle()
        }

        this.previousKeyboardD = this.keyboard.D;
    }

    /**
     * Creates a new ThrowableObject (bottle) and throws it
     * 
     */
    newBottle() {
        this.lastThrowTime = this.now;
        let bottle = new ThrowableObject(this.character.x + 100, this.character.y + 100)
        bottle.world = this;
        this.throwableObjects.push(bottle)
        bottle.throw();
        this.character.bottlesAmount--;
        this.statusBarBottles.setPercentage(this.character.bottlesAmount, 5);
        this.addingBottlesToMap()
    }

    /**
     * New Bottles will be added to the map if 2 conditions are true
     * 
     */
    addingBottlesToMap() {
        if (this.character.bottlesAmount === 0 &amp;&amp; this.level.bottles.length == 0) {
            this.level.bottles.push(...createElements('bottles', 5, 200, 100));
        }
    }

    /**
     * Plays an error Sound if the the bottles amount is less then 1 and keyboard D is pushed
     * 
     */
    errorSoundBottleThrow() {
        if (this.keyboard.D &amp;&amp; this.character.bottlesAmount &lt; 1 &amp;&amp; !this.previousKeyboardD) {
            let errorSound = new Audio('audio/error.wav');
            this.character.playSound(errorSound, soundVolume)
        }
    }

    /**
     * Kills a normal enemy and removes it from the enemy-array
     * 
     * @param {object} enemy 
     * @param {integer} index 
     */
    killEnemy(enemy, index) {
        enemy.loadImages(enemy.images_dead);
        enemy.img = enemy.imageCache[enemy.images_dead[0]];
        enemy.isDead = true;

        if (!enemy.isBoss) {
            setTimeout(() => {
                this.level.enemies.splice(index, 1);
            }, 500);
        }
    }

    /**
     * checks if the difference between lastThrowTime and the current Time is equal or bigger then 250ms
     * 
     */
    checkCoolDown() {
        this.now = Date.now();
        return (this.now - this.lastThrowTime >= this.coolDown);
    }

    /**
     * Sets world reference for all game objects and starts enemy animations.
     * 
     */
    setWorld() {
        this.character.world = this;

        this.level.enemies.forEach(enemy => {
            enemy.world = this;
            enemy.animate();
        });

        this.level.endboss.forEach(endboss => {
            endboss.world = this;
            endboss.animate();
        });

        this.level.clouds.forEach(cloud => {
            cloud.world = this;
        });
    }

    /**
     * Main render loop that draws all game objects to the canvas.
     * 
     */
    draw() {
        if (this.gameEnd) {
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            return;
        }

        if (this.statusBarEndboss) {
            this.statusBarEndboss.updateEndbossPosition();
        }

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBackground();
        this.drawStatusBars();
        this.drawGameObjects();

        if (!isPaused) {
            this.animationFrameId = requestAnimationFrame(() => this.draw());
        }
    }

    /**
    * Checks if canvas is in fullscreen and adjusts camera
    * 
    */
    checkFullscreenCamera() {
        const isFullscreen = this.canvas.height > 600;

        if (isFullscreen &amp;&amp; (!this.camera_y || this.camera_y === 0)) {
            console.log('Setting fullscreen camera');
            const extraHeight = this.canvas.height - 480;
            this.camera_y = -extraHeight + 100;
            console.log('Camera Y set to:', this.camera_y);
        } else if (!isFullscreen &amp;&amp; this.camera_y !== 0) {
            console.log('Resetting camera for normal mode');
            this.camera_y = 0;
        }
    }

    /**
     * Draws background elements with camera translation
     * 
     */
    drawBackground() {
        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.level.backgroundObjects);
        this.addObjectsToMap(this.level.clouds);
        this.ctx.translate(-this.camera_x, 0);
    }

    /**
     * Draws all status bars and UI elements.
     * 
     */
    drawStatusBars() {
        this.addToMap(this.statusBarEnergy);
        this.addToMap(this.statusBarBottles);
        this.addToMap(this.statusBarCoins);

        if (this.level.endboss[0]?.hadFirstContact) {
            this.addToMap(this.statusBarEndboss);
        }
    }

    /**
     * Draws all interactive game objects with camera translation
     * 
     */
    drawGameObjects() {
        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.level.coins);
        this.addObjectsToMap(this.level.bottles);
        this.addObjectsToMap(this.level.endboss);
        this.addObjectsToMap(this.level.enemies);
        this.addToMap(this.character);
        this.addObjectsToMap(this.throwableObjects);
        this.addObjectsToMap(this.endbossProjectiles); 
        this.addObjectsToMap(this.brokenProjectiles);
        this.ctx.translate(-this.camera_x, 0);
    }

    /**
     * Adds objects from an array to the map
     * 
     * @param {object} array 
     */
    addObjectsToMap(array) {
        array.forEach(obj => {
            this.addToMap(obj)
        });
    }

    /**
     * Adds an single Object to the map, checks the direction of it and flip the image if necessary
     * 
     * @param {object} mo 
     */
    addToMap(mo) {
        if (mo.otherDirection) {
            this.flipImage(mo)
        }
        mo.drawing(this.ctx)
        // mo.drawingFrame(this.ctx)
        if (mo.otherDirection) {
            this.flipImageBack(mo)
        }
    }

    /**
     * Flips the Image
     * 
     * @param {object} mo 
     */
    flipImage(mo) {
        this.ctx.save();
        this.ctx.translate(mo.width, 0);
        this.ctx.scale(-1, 1);
        mo.x = mo.x * -1;
    }

    /**
     * Flips the Image back 
     * 
     * @param {object} mo 
     */
    flipImageBack(mo) {
        mo.x = mo.x * -1;
        this.ctx.restore();
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Character.html">Character</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Jul 26 2025 16:56:03 GMT+0200 (Mitteleurop√§ische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
