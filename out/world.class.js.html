<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: world.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: world.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>class World {
    coolDown = 250;
    gameEnd = false;
    isPaused = false;
    characterDead = false;
    endbossDead = false;
    animationFrameId = null;
    previousKeyboardD = null;
    worldInterval;
    constructor(canvas, keyboard, level) {
        this.ctx = canvas.getContext('2d');
        this.canvas = canvas;
        this.keyboard = keyboard;
        this.level = level;
        this.character = new Character();
        this.throwableObjects = [];
        this.statusBarEnergy = new Statusbar('energy');
        this.statusBarBottles = new Statusbar('bottle');
        this.statusBarCoins = new Statusbar('coin');
        this.statusBarEndboss = new Statusbar('endboss');
        this.lastThrowTime = 0;
        this.now = 0;
        this.coin_sound = new Audio('audio/coin.mp3');
        this.draw();
        this.setWorld();
        this.run();
    }

    /**
     * This method starts the World
     * 
     */
    run() {
        this.worldInterval = setInterval(() => {
            this.checkCollisions();
            this.checkThrowObject();
        }, 100);
    }

    /**
     * This method generates a new ThrowableObject (bottle) only 
     * if the bottlesAmount is bigger then 0 and checkCoolDown is true
     * 
     */
    checkThrowObject() {
        this.errorSoundBottleThrow(); // Erst Fehlerprüfung

        if (this.keyboard.D &amp;&amp; this.checkCoolDown() &amp;&amp; this.character.bottlesAmount > 0) {
            this.newBottle()
        }

        this.previousKeyboardD = this.keyboard.D;
    }

    newBottle() {
        this.lastThrowTime = this.now;
        let bottle = new ThrowableObject(this.character.x + 100, this.character.y + 100)
        bottle.world = this;
        this.throwableObjects.push(bottle)
        bottle.throw();
        this.character.bottlesAmount--;
        this.statusBarBottles.setPercentage(this.character.bottlesAmount, 5);
        this.addingBottlesToMap()
    }

    addingBottlesToMap() {
        if (this.character.bottlesAmount === 0 &amp;&amp; this.level.bottles.length == 0) {
            console.log('adding new bottles')
            this.level.bottles.push(...createElements('bottles', 5, 200, 100));
        }
    }

    errorSoundBottleThrow() {
        console.log(this.character.bottlesAmount)
        if (this.keyboard.D &amp;&amp; this.character.bottlesAmount &lt; 1 &amp;&amp; !this.previousKeyboardD) {
            let errorSound = new Audio('audio/error.wav');
            this.character.playSound(errorSound, 1)
        }
    }

    checkCollisions() {
        if (!this.gameEnd) {
            this.characterCollisionEnemy()
            this.characterCollisionEndboss()
            this.characterCollisionCoin()
            this.characterCollisionBottle()
        }
    }

    characterCollisionEnemy() {
        for (let i = this.level.enemies.length - 1; i >= 0; i--) {
            let enemy = this.level.enemies[i];
            this.character.definingOffsetFrame();
            enemy.definingOffsetFrame();

            if (enemy.isDead === undefined) enemy.isDead = false;

            if (this.character.isColliding(enemy) &amp;&amp; !enemy.isDead) {
                if (this.character.falling &amp;&amp; this.character.y &lt; enemy.y) {
                    this.killEnemy(enemy, i);
                } else {
                    this.damageCharacter();
                }
            }
        }
    }

    killEnemy(enemy, index) {
        enemy.loadImages(enemy.images_dead);
        enemy.img = enemy.imageCache[enemy.images_dead[0]];
        enemy.isDead = true;

        if (!enemy.isBoss) {
            setTimeout(() => {
                this.level.enemies.splice(index, 1);
            }, 500);
        }
    }

    damageCharacter() {
        this.character.hit();
        this.statusBarEnergy.setPercentage(this.character.energy, 100);
    }

    characterCollisionBottle() {
        for (let i = this.level.bottles.length - 1; i >= 0; i--) {
            let bottle = this.level.bottles[i];
            this.character.definingOffsetFrame();
            bottle.definingOffsetFrame();

            if (this.character.isColliding(bottle)) {
                this.character.bottlesAmount++;
                this.statusBarBottles.setPercentage(this.character.bottlesAmount, 5);
                this.level.bottles.splice(i, 1);
            }
        }
    }
    characterCollisionCoin() {
        for (let i = this.level.coins.length - 1; i >= 0; i--) {
            let coin = this.level.coins[i];
            this.character.definingOffsetFrame();
            coin.definingOffsetFrame();

            if (this.character.isColliding(coin)) {
                this.character.coinsAmount++;
                this.character.playSound(this.coin_sound, 1)
                this.statusBarCoins.setPercentage(this.character.coinsAmount, 5);
                this.level.coins.splice(i, 1);
            }
        }
    }

    characterCollisionEndboss() {
        this.level.endboss.forEach(endboss => {
            this.character.definingOffsetFrame();
            endboss.definingOffsetFrame();
            if (this.character.isColliding(endboss) &amp;&amp; !endboss.isDead) {
                this.character.hit();
                this.statusBarEnergy.setPercentage(this.character.energy)
            };
        });
    }

    checkBottleCollisions() {
        this.throwableObjects.forEach(bottle => {
            this.bottleCollisionEnemy(bottle);
            this.bottleCollisionEndboss(bottle);
        });
    }

    bottleCollisionEnemy(bottle) {
        this.level.enemies.forEach(enemy => {
            enemy.definingOffsetFrame();
            bottle.definingOffsetFrame();
            if (bottle.isColliding(enemy)) {
                enemy.die();
                bottle.bottleSplash();
            }
        });
    }

    bottleCollisionEndboss(bottle) {
        if (this.checkCoolDown()) {
            this.lastThrowTime = this.now;
            this.level.endboss.forEach(endboss => {
                endboss.definingOffsetFrame();
                bottle.definingOffsetFrame();
                if (bottle.isColliding(endboss)) {
                    endboss.hit();
                    bottle.bottleSplash();
                }
            });
        }
    }

    checkCoolDown() {
        this.now = Date.now();
        return (this.now - this.lastThrowTime >= this.coolDown);
    }

    setWorld() {
        this.character.world = this;

        this.level.enemies.forEach(enemy => {
            enemy.world = this;
            enemy.animate();
        });

        this.level.endboss.forEach(endboss => {
            endboss.world = this;
            endboss.animate();
        });

        this.level.clouds.forEach(cloud => {
            cloud.world = this;
        });
    }

    draw() {
        if (this.gameEnd) {
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
            }
            return;
        }

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.level.backgroundObjects);
        this.addObjectsToMap(this.level.clouds);
        this.ctx.translate(-this.camera_x, 0);

        this.addToMap(this.statusBarEnergy);
        this.addToMap(this.statusBarBottles);
        this.addToMap(this.statusBarCoins);

        if (this.level.endboss[0]?.hadFirstContact) {
            this.addToMap(this.statusBarEndboss);
        }

        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.level.coins);
        this.addObjectsToMap(this.level.bottles);
        this.addObjectsToMap(this.level.endboss);
        this.addObjectsToMap(this.level.enemies);
        this.addToMap(this.character);
        this.addObjectsToMap(this.throwableObjects);
        this.ctx.translate(-this.camera_x, 0);

        if (isPaused) return;

        this.animationFrameId = requestAnimationFrame(() => this.draw());
    }

    addObjectsToMap(array) {
        array.forEach(obj => {
            this.addToMap(obj)
        });
    }

    addToMap(mo) {
        if (mo.otherDirection) {
            this.flipImage(mo)
        }
        mo.drawing(this.ctx)
        if (mo.otherDirection) {
            this.flipImageBack(mo)
        }
    }

    flipImage(mo) {
        this.ctx.save();
        this.ctx.translate(mo.width, 0);
        this.ctx.scale(-1, 1);
        mo.x = mo.x * -1;
    }

    flipImageBack(mo) {
        mo.x = mo.x * -1;
        this.ctx.restore();
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Jul 20 2025 20:16:26 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
